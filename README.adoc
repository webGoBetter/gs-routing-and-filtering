---
tags: [spring cloud, zuul]
projects: [spring-cloud, spring-cloud-netflix]
---
:spring_version: current
:spring_boot_version: 1.2.8.RELEASE
:DataSource:
:toc:
:icons: font
:source-highlighter: prettify
:project_id: gs-routing-and-filtering

本指南会带你了解使用Netflix Zuul边缘服务库，将请求路由和过滤到微服应用的过程。

== 你将构建什么

你会写的一个简单的微服务应用，然后建立反向代理的应用程序，代理应用使用 https://github.com/spring-cloud/spring-cloud-netflix[Netflix Zuul] 来转发请求到服务应用。 您还将看到如何使用Zuul过滤通过代理服务的请求。

== 你需要什么

:java_version: 1.8
include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/how_to_complete_this_guide.adoc[]

[[reveal-gradle]]
[.reveal-gradle]
== 使用Gradle构建

[[scratch]]
[.use-gradle]
== 使用Gradle构建

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/build_system_intro.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_directory_structure_hello.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_both_builds.adoc[]

`book/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/book/build.gradle[]
----

`gateway/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/gateway/build.gradle[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-gradle-plugin.adoc[]

[[reveal-maven]]
[.reveal-maven]
== 使用Maven构建

[[use-maven]]
[.use-maven]
== 使用Maven构建

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/build_system_intro_maven.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_directory_structure_hello.adoc[]

`book/pom.xml`
[source,xml]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/book/pom.xml[]
----

`gateway/pom.xml`
[source,xml]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/gateway/pom.xml[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-maven-plugin.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/hide-show-sts.adoc[]


[[initial]]
== 建立一个微服务

预定服务将非常简单。编辑 `BookApplication.java` ，让它看起来像这样：

`book/src/main/java/hello/BookApplication.java`
[source,java]
----
include::complete/book/src/main/java/hello/BookApplication.java[]
----

`BookApplication` 类显示是一个 REST 风格的控制器. `@RestController` 标记的类作为一个控制器类，也确保这个类中的 `@RequestMapping` 方法的返回值会被自动转换成适当的值直接写入HTTP响应。

说到 `@RequestMapping` 方法，我们已经增加了两个：`available()` 和 `checkedOut()` 。他们处理请求的路径 `/available` 和 `/checked-out` ，每个只需返回预定名字的 `String` 。

将 `src/main/resources/application.properties` 中的应用名字设置为 (`book`) 。

`book/src/main/resources/application.properties`
[source,properties]
----
include::complete/book/src/main/resources/application.properties[]
----

我们也在这里设置 `server.port` ，这样当我们在本地同时启动并运行服务时，它就不会与我们的边缘服务发生冲突。


== 创建一个边缘服务

Spring Cloud Netflix包括嵌入式Zuul的代理，对它我们可以使用 `@EnableZuulProxy` 注释。这将使网关应用程序变成反向代理，将相关调用转发给其他服务，比如我们的预定服务。

打开网关应用的 `GatewayApplication` 类，然后添加注解，像这样：

`gateway/src/main/java/hello/GatewayApplication.java`
[source,java]
----
package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@EnableZuulProxy
@SpringBootApplication
public class GatewayApplication {

  public static void main(String[] args) {
    SpringApplication.run(GatewayApplication.class, args);
  }

}
----

为了转发来自网关的请求，我们需要告诉Zuul它需要观察的路由，和那些经过需要这些路由转发的服务。我们用 `zuul.routes` 属性指定路由。我们的每一个微服务都有定义了 `zuul.routes.NAME` 实例，这个 `NAME` 是应用名(存储在 `spring.application.name` 属性中)。

 添加一个 `application.properties` 文件到我们网关应用的新路径中， `src/main/resources` 。他看起来像这样：

`gateway/src/main/resources/application.properties`
[source,properties]
----
include::complete/gateway/src/main/resources/application.properties[]
----

Spring Cloud Zuul 将自动设置应用程序名称。在这个样本，因为我们设置 `zuul.routes.books.url` ,因此Zuul将代理 `/books` 请求到这个URL。

注意到我们文件中第二个到最后一个属性： Spring Cloud Netflix Zuul 使用Netflix的 Ribbon负责客户端负载均衡，默认情况下，Ribbon会用Netflix Eureka作为服务发现。在这个简单的例子中，我们跳过服务发现，因此我们设置 `ribbon.eureka.enabled` 为 `false` ，因为Ribbon现在开始不能使用Eureka发现服务，我们必须为预定服务指定 `url` 。

== 添加一个过滤器

现在让我们看看如何通过代理服务过滤请求。Zuul有四个标准的过滤器类型：

- **pre** 过滤器会在请求被路由前执行,
- **route** 过滤器处理实际的请求路由,
- **post** 过滤器在请求被路由了之后执行，
- **error** 过滤器会在处理请求时遇到错误时被执行.

我们将写一个 _pre_ 过滤器. Spring Cloud Netflix 选择, 作为一个过滤器, 任何一个继承了  `com.netflix.zuul.ZuulFilter` 类并且在应用程序上下文中的 `@Bean` . 创建一个目录, `src/main/java/hello/filters/pre`, 然后在里面创建一个文件, `SimpleFilter.java`:

`gateway/src/main/java/hello/filters/pre/SimpleFilter.java`
[source,java]
----
include::complete/gateway/src/main/java/hello/filters/pre/SimpleFilter.java[]
----

过滤器类实现了四个方法:

- `filterType()` returns a `String` that stands for the type of the filter---in this case, `pre`, or it could be `route` for a routing filter.
- `filterOrder()` gives the order in which this filter will be executed, relative to other filters.
- `shouldFilter()` contains the logic that determines when to execute this filter (this particular filter will _always_ be executed).
- `run()` contains the functionality of the filter.

Zuul filters store request and state information in (and share it by means of) the `RequestContext`. We're using that to get at the `HttpServletRequest`, and then we log the HTTP method and URL of the request before it is sent on its way.

The `GatewayApplication` class is annotated with `@SpringBootApplication`, which is equivalent to (among others) the `@Configuration` annotation that tells Spring to look in a given class for `@Bean` definitions. Add one for our `SimpleFilter` here:

`gateway/src/main/java/hello/GatewayApplication.java`
[source,java]
----
include::complete/gateway/src/main/java/hello/GatewayApplication.java[]
----


== 试一试

Make sure that both applications are running. In a browser, visit one of the Book application's endpoints via the Gateway application. If you've used the configuration shown in this guide, you can access the Book service directly at `localhost:8090` and via the Gateway service at `localhost:8080/books`.

Visit one of the Book service endpoints, as `localhost:8080/books/available`, and you should see your request's method logged by the Gateway application before it's handed on to the Book application:

----
2016-01-19 16:51:14.672  INFO 58807 --- [nio-8080-exec-6] hello.filters.pre.SimpleFilter           : GET request to http://localhost:8080/books/available
2016-01-19 16:51:14.672  INFO 58807 --- [nio-8080-exec-6] o.s.c.n.zuul.filters.ProxyRouteLocator   : Finding route for path: /books/available
----

== 恭喜

祝贺你!你刚才用Spring 开发了一个边缘服务应用，可以为您的微服务代理和过滤的要求。

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/footer.adoc[]
